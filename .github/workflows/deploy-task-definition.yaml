name: Deploy task definition

on:
  workflow_dispatch:
    inputs:
      model:
        description: "Model directory"
        required: true
        type: string
      
env:
  AWS_REGION: "eu-west-1"
  ECS_CLUSTER: "poc-deployment-cluster"
  ECR_REPOSITORY: "poc-deployment"

permissions:
  id-token: write # Required for OIDC authentication to assume AWS role
  contents: read  # Required to read repository contents (e.g., Dockerfile, config) during workflow 

jobs:
  deploy-task:
    name: Deploy Task manifest file
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Codebase
        uses: actions/checkout@v5
        with:
          ref: main

      - name: Extract configurations for other steps
        id: parse
        shell: bash
        run: |
          set -euo pipefail

          MODEL_DIR="${{ inputs.model }}"       

          # ------------------------------------------
          # Check required files and directories exist
          # ------------------------------------------
          MODEL_PATH="models/${MODEL_DIR}"
          CONFIG_PATH="models_config/${MODEL_DIR}/config.yaml"
          DOCKERFILE_PATH="${MODEL_PATH}/Dockerfile"
          PYTHON_VERSION_FILE="${MODEL_PATH}/.python-version"
          PYPROJECT="${MODEL_PATH}/pyproject.toml"
          UV_LOCK_FILE="${MODEL_PATH}/uv.lock"
          SRC_FOLDER="${MODEL_PATH}/src"

          [[ -f "${DOCKERFILE_PATH}" ]] || { echo "ERROR: Missing Dockerfile at ${DOCKERFILE_PATH}" >&2; exit 1; }
          [[ -f "${PYTHON_VERSION_FILE}" ]] || { echo "ERROR: Missing .python-version at ${PYTHON_VERSION_FILE}" >&2; exit 1; }
          [[ -f "${CONFIG_PATH}" ]] || { echo "ERROR: Missing config.yaml at ${CONFIG_PATH}" >&2; exit 1; }
          [[ -f "${PYPROJECT}" ]] || { echo "ERROR: Missing pyproject.toml at ${PYPROJECT}" >&2; exit 1; }
          [[ -f "${UV_LOCK_FILE}" ]] || { echo "ERROR: Missing uv lock file at ${UV_LOCK_FILE}" >&2; exit 1; }
          [[ -d "${SRC_FOLDER}" ]] || { echo "ERROR: Missing src folder at ${SRC_FOLDER}" >&2; exit 1; }
        
        
          # Read python version
          PYTHON_VERSION="$(head -n 1 "$PYTHON_VERSION_FILE" | tr -d '[:space:]')"

          validate_not_empty() {
            local name="$1"
            local value="$2"
            if [[ -z "$value" || "$value" == "null" ]]; then
                echo "ERROR: '${name}' is missing or empty." >&2
                exit 1
            fi
          }

          validate_not_empty ".python-version" "$PYTHON_VERSION"
          
          
          # --------------------------------------
          # Output values for later workflow steps
          # --------------------------------------
          {
            echo "model_dir=${MODEL_DIR}"
            echo "model_path=${MODEL_PATH}"
            echo "dockerfile_path=${DOCKERFILE_PATH}"
            echo "python_version=${PYTHON_VERSION}"
            echo "config_path=${CONFIG_PATH}"
          } >> "$GITHUB_OUTPUT"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to AWS ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Setup Docker Buildx
        shell: bash
        run: |
          set -euo pipefail
          docker buildx create --use

      - name: Build and Push Image
        id: build-push-image
        shell: bash
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: "${{ steps.parse.outputs.model_dir }}-latest"
          DOCKERFILE_PATH: ${{ steps.parse.outputs.dockerfile_path }}
          BUILD_CONTEXT: ${{ steps.parse.outputs.model_path }}
          PYTHON_VERSION: ${{ steps.parse.outputs.python_version }}
        run: |
          set -euo pipefail
          echo "INFO: Building and pushing: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

          docker buildx build \
            --file "$DOCKERFILE_PATH" \
            --tag "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" \
            --platform linux/amd64 \
            --build-arg PYTHON_VERSION="$PYTHON_VERSION" \
            --push \
            "$BUILD_CONTEXT"

          echo "INFO: Image pushed successfully."
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> "$GITHUB_OUTPUT"

      # ----------------------------------------
      # Render ECS task definition from template
      # ----------------------------------------
      - name: Render ECS task definition
        id: render-taskdef
        shell: bash
        env:
          FAMILY: ${{ steps.parse.outputs.model_dir }}-poc-deployment-task
          TASK_ROLE_ARN: arn:aws:iam::463470983643:role/${{ steps.parse.outputs.model_dir }}-poc-deployment-task-role
          EXEC_ROLE_ARN: arn:aws:iam::463470983643:role/${{ steps.parse.outputs.model_dir }}-poc-deployment-task-execution-role
          IMAGE: ${{ steps.build-push-image.outputs.image }}
          LOG_GROUP: poc-deployment-${{ steps.parse.outputs.model_dir }}-logs
        run: |
          ./render-task-def.sh ${{ steps.parse.outputs.config_path }} taskdef.template.json taskdef.rendered.json

      - name: Deploy Amazon ECS Task Definition
        id: deploy-ecs-task
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        with:
          task-definition: taskdef.rendered.json
          service: ${{ steps.parse.outputs.model_dir }}-poc-deployment-service
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
          wait-for-minutes: 20

      - name: Send Slack Notification (success)
        if: ${{ success() && steps.deploy-ecs-task.outcome == 'success' }}
        uses: slackapi/slack-github-action@v2.0.0
        with:
          method: chat.postMessage
          token: ${{ secrets.SLACK_BOT_TOKEN }}
          payload: |
            {
              "channel": "${{ vars.SLACK_CHANNEL_ID }}",
              "text": "‚úÖ üöÄ ECS deployment successful: *${{ steps.parse.outputs.model_dir }}*",
              "attachments": [
                {
                  "color": "2EB67D",
                  "fields": [
                    { "title": "Cluster", "value": "${{ env.ECS_CLUSTER }}", "short": true },
                    { "title": "Service", "value": "${{ steps.parse.outputs.model_dir }}-poc-deployment-service", "short": true },
                    { "title": "Run", "value": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}", "short": false }
                  ]
                }
              ]
            }

      - name: Send Slack Notification (failure)
        if: ${{ always() && steps.deploy-ecs-task.outcome == 'failure' }}
        uses: slackapi/slack-github-action@v2.0.0
        with:
          method: chat.postMessage
          token: ${{ secrets.SLACK_BOT_TOKEN }}
          payload: |
            {
              "channel": "${{ vars.SLACK_CHANNEL_ID }}",
              "text": "‚ùå ECS deployment failed: *${{ steps.parse.outputs.model_dir }}*",
              "attachments": [
                {
                  "color": "E01E5A",
                  "fields": [
                    { "title": "Cluster", "value": "${{ env.ECS_CLUSTER }}", "short": true },
                    { "title": "Service", "value": "${{ steps.parse.outputs.model_dir }}-poc-deployment-service", "short": true },
                    { "title": "Run", "value": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}", "short": false }
                  ]
                }
              ]
            }

      - name: Clean up Docker
        if: always()
        run: docker system prune --all --force
