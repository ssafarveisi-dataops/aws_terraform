name: Deploy ECS task definition

on:
  workflow_dispatch:
    inputs:
      reason:
        description: "Reason for manual trigger"
        required: false
        type: string
env:
  AWS_REGION: "eu-central-1"
  S3_BUCKET: "dataops-poc-deployment"
  ECS_CLUSTER: "poc-deployment-cluster"

permissions:
  id-token: write
  contents: read

jobs:
    discover:
      runs-on: ubuntu-latest
      outputs:
        matrix: ${{ steps.set-matrix.outputs.matrix }}
      steps:
        - uses: actions/checkout@v5
          with:
            ref: main

        - id: set-matrix
          shell: bash
          run: |
            set -euo pipefail

            # Find direct subdirectories under models/
            mapfile -t dirs < <(find models -mindepth 1 -maxdepth 1 -type d -print | sort)

            if [ ${#dirs[@]} -eq 0 ]; then
              echo 'matrix={"include":[]}' >> "$GITHUB_OUTPUT"
              exit 0
            fi

            json='{"include":['
            first=1

            for d in "${dirs[@]}"; do
              name="$(basename "$d")"
              dockerfile="$d/Dockerfile"
              pyproject="$d/pyproject.toml"
              python_version_file="$d/.python-version"

              # Skip folders without necessary files
              if [ ! -f "$dockerfile" ]; then
                echo "Skipping $d (no Dockerfile)"
                continue
              fi
              if [ ! -f "$pyproject" ]; then
                echo "Skipping $d (no pyproject.toml)"
                continue
              fi
              if [ ! -f "$python_version_file" ]; then
                echo "Skipping $d (no .python-version)"
                continue
              fi

              # Extract version from pyproject.toml (Poetry-style)
              version="$(grep -E '^[[:space:]]*version[[:space:]]*=' "$pyproject" | head -n1 | sed -E 's/.*"([^"]+)".*/\1/')"

              if [ -z "$version" ]; then
                echo "Skipping $d (could not parse version in pyproject.toml)"
                continue
              fi

              # Read the Python version (first line)
              python_version="$(head -n 1 "$python_version_file" | tr -d '[:space:]')"

              if [ -z "$python_version" ]; then
                echo "Skipping $d (empty .python-version)"
                continue
              fi

              # Append to matrix JSON
              [ $first -eq 0 ] && json+=',' || first=0
              json+="{\"name\":\"$name\",\"context\":\"$d\",\"dockerfile\":\"$dockerfile\",\"version\":\"$version\",\"python_version\":\"$python_version\"}"
            done

            json+=']}'
            echo "matrix=$json" >> "$GITHUB_OUTPUT"
            echo "$json"

    deploy-task:
      needs: discover
      name: 'Deploy Task manifest file'
      if: ${{ fromJSON(needs.discover.outputs.matrix).include[0] != null }}
      runs-on: ubuntu-latest
      strategy:
        matrix: ${{ fromJSON(needs.discover.outputs.matrix) }}
        fail-fast: false

      steps:  
        - name: Checkout Codebase
          uses: actions/checkout@v5
          with:
            ref: main

        - name: Configure AWS Credentials
          uses: aws-actions/configure-aws-credentials@v5
          with:
            role-to-assume: ${{ secrets.ROLE_ARN }}
            role-session-name: GitHub_to_AWS_via_FederatedOIDC
            aws-region: ${{ env.AWS_REGION }}
        
        - name: Get AWS Account ID
          id: get-account
          run: |
            ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
            echo "account=$ACCOUNT_ID" >> $GITHUB_OUTPUT

        - name: Login to AWS ECR
          id: login-ecr
          uses: aws-actions/amazon-ecr-login@v2
        
        - name: Setup Docker Buildx
          run: docker buildx create --use
          
        - name: Build and Push Image
          id: build-push-image
          env:
            ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
            ECR_REPOSITORY: dataops-poc-deployment
            IMAGE_TAG: ${{ matrix.name }}-${{ matrix.version }}
            DOCKERFILE_PATH: ${{ matrix.dockerfile }}
            BUILD_CONTEXT: ${{ matrix.context }}
            PYTHON_VERSION: ${{ matrix.python_version }}
          run: |
            set -euo pipefail
            echo "Building and pushing: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
            docker buildx build \
              --file $DOCKERFILE_PATH \
              --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
              --platform linux/amd64 \
              --build-arg $PYTHON_VERSION \
              --push \
              $BUILD_CONTEXT
            echo "Image built and pushed successfully."
            echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> "$GITHUB_OUTPUT"
        
         # aws-actions/amazon-ecs-render-task-definition is not useable here
        - name: Render ECS task definition
          id: render-taskdef
          shell: bash
          env:
            FAMILY: "${{ matrix.name }}-poc-deployment-task"               
            TASK_ROLE_ARN: "arn:aws:iam::${{ steps.get-account.outputs.account }}:role/${{ matrix.name }}-poc-deployment-task-role" 
            EXEC_ROLE_ARN: "arn:aws:iam::${{ steps.get-account.outputs.account }}:role/${{ matrix.name }}-poc-deployment-task-execution-role"
            IMAGE: "${{ steps.build-push-image.outputs.image }}"
            S3_BUCKET: ${{ env.S3_BUCKET }}
            S3_PREFIX: ${{ matrix.name }}
            ROOT_PATH: ${{ matrix.name }}
            LOG_GROUP:  "${{ matrix.name }}-litserve-logs"              
            AWS_REGION: ${{ env.AWS_REGION }}                 
          run: |
            set -euo pipefail

            TEMPLATE="task-definition.template.json"
            OUT="task-definition.json"

            COMMAND_JSON='[]'

            jq \
              --arg family "$FAMILY" \
              --arg taskRoleArn "$TASK_ROLE_ARN" \
              --arg executionRoleArn "$EXEC_ROLE_ARN" \
              --arg image "$IMAGE" \
              --arg s3_bucket "$S3_BUCKET" \
              --arg s3_prefix "$S3_PREFIX" \
              --arg root_path "$ROOT_PATH" \
              --arg log_group "$LOG_GROUP" \
              --arg region "$AWS_REGION" \
              --argjson command "$COMMAND_JSON" \
              '
              .family = $family
              | .taskRoleArn = $taskRoleArn
              | .executionRoleArn = $executionRoleArn
              | .containerDefinitions[0].image = $image
              | .containerDefinitions[0].command = $command
              | (.containerDefinitions[0].environment |=
                  map(
                    if .name == "S3_BUCKET" then .value = $s3_bucket
                    elif .name == "S3_PREFIX" then .value = $s3_prefix
                    elif .name == "ROOT_PATH" then .value = $root_path
                    else .
                    end
                  )
                )
              | .containerDefinitions[0].logConfiguration.options["awslogs-group"] = $log_group
              | .containerDefinitions[0].logConfiguration.options["awslogs-region"] = $region
              ' "$TEMPLATE" > "$OUT"

            echo "taskdef=$OUT" >> "$GITHUB_OUTPUT"
            echo "Rendered $OUT:"
            cat "$OUT"

        - name: Deploy Amazon ECS Task Definition
          id: deploy-ecs-task
          uses: aws-actions/amazon-ecs-deploy-task-definition@v2
          with:
            task-definition: ${{ steps.render-taskdef.outputs.taskdef }}
            service: ${{ matrix.name }}-poc-deployment-service
            cluster: ${{ env.ECS_CLUSTER }}
            wait-for-service-stability: true
            wait-for-minutes: 20
        
        - name: Send Slack Notification (success)
          if: ${{ success() && steps.deploy-ecs-task.outcome == 'success' }}
          uses: slackapi/slack-github-action@v2.0.0
          with:
            method: chat.postMessage
            token: ${{ secrets.SLACK_BOT_TOKEN }}
            payload: |
              {
                "channel": "${{ vars.SLACK_CHANNEL_ID }}",
                "text": "‚úÖ üöÄ ECS deployment successful: *${{ matrix.name }}*",
                "attachments": [
                  {
                    "color": "2EB67D",
                    "fields": [
                      { "title": "Cluster", "value": "${{ env.ECS_CLUSTER }}", "short": true },
                      { "title": "Service", "value": "${{ matrix.name }}-poc-deployment-service", "short": true },
                      { "title": "Run", "value": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}", "short": false }
                    ]
                  }
                ]
              }

        - name: Send Slack Notification (failure)
          if: ${{ always() && steps.deploy-ecs-task.outcome == 'failure' }}
          uses: slackapi/slack-github-action@v2.0.0
          with:
            method: chat.postMessage
            token: ${{ secrets.SLACK_BOT_TOKEN }}
            payload: |
              {
                "channel": "${{ vars.SLACK_CHANNEL_ID }}",
                "text": "‚ùå ECS deployment failed: *${{ matrix.name }}*",
                "attachments": [
                  {
                    "color": "E01E5A",
                    "fields": [
                      { "title": "Cluster", "value": "${{ env.ECS_CLUSTER }}", "short": true },
                      { "title": "Service", "value": "${{ matrix.name }}-poc-deployment-service", "short": true },
                      { "title": "Run", "value": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}", "short": false }
                    ]
                  }
                ]
              }

        - name: Log deployment
          if: always()
          run: |
            echo "Deployment triggered by: ${{ github.event_name }}"
            if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
              echo "Manual trigger reason: ${{ github.event.inputs.reason }}"
            fi

        - name: Clean up Docker
          if: always()
          run: docker system prune --all --force